Avionics Systems uses Formatted Rich Text as originally defined in RasterPropMonitor
with some minor changes.

BASIC TEXT

Static or unchanging text such as might be used for labels on controls and instruments
may be listed directly:

(in a config file)
text = RCS

This will evaluate to the text "RCS".

VARIABLE TEXT

Text may contain variables that are evaluated, allowing for changing text.  This
text might be used for digital displays, or for monitors.  Text expressed in this
way follows the C# standards for formatting, with some extensions to the formatting
string, as detailed below.

To separate the formatting text from the variable list, the token '$&$' is inserted
at the end of the formatting string, before the variable list:

Altitude: {0:#####0.0}m $&$ fc.GetAltitude()

Because variables in MAS are evaluated as snippets of Lua, the RasterPropMonitor convention
of separating variables with spaces has been replaced with using a comma ',':

Ap: {0:#####0.0}km / Pe: {1:#####0.0}km $&$ fc.GetApoapsis() / 1000, fc.GetPeriapsis() / 1000

Note in this case that in addition to using two variables, we are also converting the Ap
and Pe from meters to km.  Lua allows us to include mathematical expressions in our
variables.

MULTILINE TEXT

Monitor pages can use layout info stored in text files, like RasterPropMonitor
page definition files.  In a page definition file, the text rows use the end-of-lines
to separate rows of text.  In an inline text definition, such as the TEXT_LABEL action
of a MASComponent, end-of-line doesn't work.  Instead the token '$$$' may be used to
indicate a new line.  Note that this token is translated directly into a new line
character, so the following would not work:

 ALT: {0:#####.0}m $$$ RALT: {1:#####.0}m $&$ fc.GetAltitude(), fc.GetRadarAltitude()

That text would be converted to

 ALT: {0:#####.0}m 
RALT: {1:#####.0}m $&$ fc.GetAltitude(), fc.GetRadarAltitude()

which will generate a string formatting exception, since there is no variable on the first row.
Instead, the text needs to be defined as 

 ALT: {0:#####.0}m $&$ fc.GetAltitude() $$$ RALT: {0:#####.0}m $&$ fc.GetRadarAltitude()

RICH TEXT

Text may include expressions that allow for additional effects.  These expressions are
enclosed in square brackets '[' and ']'.  Rich Text is processed after variables have
been evaluated, so it is possible (and common) to use variables inside rich text
tags.

Color tags [#rrggbb(aa)]

Text color can be changed on the fly by using the color tag.  Colors are expressed as
hexadecimal RGB or RGBA sequences, similar to how colors are often expressed within HTML
pages.  For instance,

This is [#ff0000]RED[#ffffff] text.

will display "This is" in the default text color, "RED" in red, and "text." in white.
Once a color token has been used, it is applied until another color token is found,
or the text reaches the end of the line.  The alpha values are optional, and they
default to 255 (ff) if they are omitted.  There is no option to reset the color to
the default text color within a line of text once it's been changed.

X and Y nudge tags [@x#] and [@y#]

Text position can be changed using nudge tags.  On an MFD (MASMonitor), a nudge moves
the text by a number of pixels
from its default position (the position the character would have been drawn at using
[@x0][@y0]).  Positive X values move the text to the right, negative values to the
left.  Positive Y moves the text down, negative moves up.  Using [@x0][@y0] moves the
text back to its normal position [[MOARdV TODO - double check this]].  Since variables are permitted,
one common technique is to use nudges to move text on a monitor, such as cues for
docking alignment or altimeter strips.  Nudges reset at the end of a row of text.

With Label Text in a MASComponent, the nudge moves the text by an amount based on
the resolution of the underlying font, but the distance is affected by scaling and
other factors, so it may require some tuning to position it correctly.  Note that
the nudge tags do not affect text alignment computations, so results may not be
ideal with center-justified or right-justified text that uses x-nudges.

Text Style tags [b][/b] and [i][/i]

These tags allow the use of bold or italic font styles for fonts that support
those styles.  Like the other nudges, these modifiers reset at the end of the
row of text.  However, they can be terminated early using an HTML-style token.

This text is [b]bold[/b] [i][b]and[/b] italic[/i].

Style tags do not nest: the text after "[b][b][/b]" will not be bold.  Open and
close bold and italic tags can be intermingled - "[b]B[i]BI[/b]I[/i]" is perfectly
legal.

Half-width and double-width tags [hw][/hw] and [dw][/dw]

These tags shrink or stretch text horizontally.  Half-width [hw] means each character
is half as wide as normal, and the character advances 1/2 the amount as well.
Double-width [dw] means the text is twice as wide.  Each option is terminated using
an HTML-style closing tag (eg [/hw] or [/dw]).

Since these tags do not follow strict HTML guidelines, either [/hw] or [/dw] will
cancel either half-width or double-width text.  A [hw] or [dw] tag will override a
prior [hw] or [dw] tag on the same text row.

Width tags are reset at the end of a line.

--- TODO: other RPM nudges ---

Superscript and subscript tags [sup][/sup] and [sub][/sub]
- easy to implement

Font select tags [font#]
- not easy to implement (need multiple materials / Font classes)

CUSTOM FORMATTING

SI Prefixes (SIP)

Numbers may be formatted with SI Prefixes (k, M, G, etc).  The prefixes
are automatically added to the end of the number, with a blank character ' '
when there is no prefix.  The formatting string is otherwise treated like a
regular formatting string:

Format      12.34     123456
{0:SIP##0}  '12 '     '123k'
{0:SIP000}  '000 '    '123k'
{0:SIP0.00} '12.34 '  '123.46k' (due to rounding)

Date Formatting (KDT and MET)

Times may be converted to custom date/time formatting using KDT and MET.  The
difference between the two formats is in the treatment of the year ('y' and 'Y') and days of the year
(lower-case 'd'): KDT treats it as a calendar date, with the first year of the
game identified as Year 1, and the first day of the year identified as Day 1.
The MET prefix start both at 0.  The two are otherwise identical.  The formatting
automatically adjusts to Earth time or Kerbin time depending on game settings.

The following reserved characters have special meaning in a date.  All other
characters are passed through unchanged.  Repeating one of the letters will
zero pad that field (for Year 1, 'YYYY' will be '0001').

'+': Insert a '+' if the date is positive, or a '-' if it is negative.
'-': Insert a '-' if the date is negative, or do nothing if it is positive.
'Y', 'y': Insert the year.
'D': Insert the number of days, ignoring years (so 400 in Earth days will be 400, not 35).
'd': Insert the number of days, accounting for years.
'H': Insert the number of hours, ignoring days and years.
'h': Insert the number of hours, accounting for days.
'M': Insert the number of minutes, ignoring hours.
'm': Insert the number of minutes, accounting for hours.
'S': Insert the number of seconds, ignoring minutes.
's': Insert the number of seconds, accounting for  minutes.
'f': Insert fractions of a second.

LAT and LON

Treat the variable as either Latitude or Longitude, depending on the prefix.
If a '0' follows the LAT or LON keyword, degrees are zero padded.  If the value
is illegal (>90 or <-90 for Lat, >180 or <-180 for Lon), it is clamped to the
nearest limit.

For Latitude, the format is DD+ MM+ SS+ @.  For Longitude, the format is
DDD+ MM+ SS+ @.

D = degrees.  If LAT0 or LON0 is used, the degrees are zero padded.  Otherwise,
they are padded with blanks.
M = minutes of arc.  Minutes are always zero padded.
S = seconds of arc.  Seconds are always zero padded.
+ = symbol.  The appropriate symbol °, ', or ".
@ = The letter N or S for latitude, or E or W for longitude.
