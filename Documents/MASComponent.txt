The MASComponent module is the main functional block of Avionics Systems.  By itself, the MASComponent does nothing useful,
but it is composed of multiple MASAction objects, each of which is defined in the MASAction's config block.

All MASAction config blocks include a 'name' field.  This is an /optional/ field that can be used to name the block, so if
there is a configuration error, the output log will contain a name to help identify the problem.  It can potentially allow
Module Manager scripts to edit the config, as well.  You are not required to include a name.

Setup:

MODULE
{
  name = MASComponent
  // one or more MASAction actions as described below
}

CAUTION: Only use one MASComponent per prop.  Multiple MASComponent modules will lead to incorrect behavior.

Modes:

Many of the MASAction objects may operate in several modes.

Static Mode: Static mode does not use a variable.  It is used to make a one-time change to a value at initialization,
which is useful for techniques such as texture atlasing and color shifting.

Boolean Mode: In boolean mode, the variable is assumed to be either true or false.  Since all variables in MAS are
a number or string, this means that strings are always treated as 'false'. Numbers are treated as 'true' if
they are greater than 0 and 'false' if they are equal to or less than zero.  This mode is good for simple animated
switches and actions (illuminating backlights or signal flags, for instance).

Threshold Mode: In threshold mode, the variable is treated as 'true' when its value falls between the two values
specified in 'range', and it is treated as 'false' when it is not between those values.  The order of the values in
'range' does not matter, and either or both value can be a constant number or a Lua script. Eg, to test if an orbit
will aerobrake, but doesn't yet hit the surface, the range would be '0, fc.GetCurrentBodyAtmTop()'.

Blend Mode: In blend mode, the variable is linearly interpolated between the two values in 'range', with a result ranging
from 0 to 1 depending on how close to either variable it is.  The order of the range matters in this case,
since the blended variable will be 0 if it is equal to the first range value, and 1 if it equals the second.

There are many MASAction objects:


ANIMATION_PLAYER

This action plays an animation in response to the state of a variable.  It also provides control of the animation playback
speed.  It can operate in Boolean Mode and Threshold Mode.

ANIMATION_PLAYER
{
    name = swToggle
    animation = SwitchTumbleAnim
    //speed = 1.0
    variable = fc.GetRCS()
    //range = 0.5,1.5
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'animation': Required.  The name of the animation that is triggered by the variable changing.
'speed': Optional.  Default 1.0.  Used to adjust animation playback rate.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Animation Player operates in Threshold Mode.  When absent, the player operates
in Boolean Mode.


AUDIO_PLAYER

This action plays audio when a variable transitions into or out of a specified range.
This action can operate in Boolean Mode or Threshold Mode.

The audio can be configured to play in one of four modes:

ON: Play the audio clip once when the variable goes true / in range.
OFF: Play the audio clip once when the variable goes false / out of range.
BOTH: Play the audio clip once for any transition (going true or going false).
LOOP: Loop the audio as long as the variable is true / in range.

AUDIO_PLAYER
{
	name = Clicker
	sound = ASET/ASET_Props/Sounds/tumbleClick01
	//volume = 1.0
	trigger = BOTH
	variable = fc.GetPersistent("Backlight")
	//range = 0.5, 1.5
	//mustPlayOnce = false
	//pitch = fc.AtmosphereDepth()
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'sound': Required.  The URI to the audio clip to play.
'volume': Optional.  Default 1.0.  The volume at which the audio should be played (a range between 0 and 1).  May use either a variable or a constant number.
'trigger': Required.  The conditions under which the audio is played, as explained
in the text above.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Audio Player operates in Threshold Mode.  When absent, the player operates
in Boolean Mode.
'mustPlayOnce': Optional.  When true, the audio clip will be played completely, even if the controlling variable goes
out of range.  Not valid with trigger = LOOP.
'pitch': Optional.  Default 1.0.  The pitch for the audio playback.  May be a variable or a constant number.


COLLIDER_EVENT

A Collider Event action is used to respond to button presses and releases.

COLLIDER_EVENT
{
    name = Toggle switch
    collider = SwitchColider
    onClick = fc.ToggleRCS()
    //onRelease = fc.ToggleRCS()
	//autoRepeat = 0.1
	//sound = 
	//volume = 
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The transform in the prop that contains a collider.
'onClick', 'onRelease': One or the other is required; both may be present.  A Lua Action to trigger when the prop's
transform is clicked or released.  If both are present, the switch may be used for momentary events.
'autoRepeat': Optional.  Default 0.0.  When set to a positive number, the 'onClick' event
triggers every 'autoRepeat' seconds until the button is released.  It is possible to use autoRepeat, onClick, and onRelease
in the same Collider Event.
'sound': Optional.  Required if 'volume' is present.  When present, plays the specified audio when the click event
fires.
'volume': Optional.  Required if 'sound' is present.  Adjusts the volume of the click sound.


COLOR_SHIFT

A Color Shift action is used to change the color of part of the prop in response to a controlling variable.  Like
an animation player, this control can be used in Boolean Mode or Threshold Mode.  However,
unlike the animation player, the Color Shift can be configured to blend between the two colors using
Blend Mode, and it supports Static Mode.  In this case, the value is interpolated between the first and second
values of the range, and the resulting value is used to blend between the two color settings.

COLOR_SHIFT
{
    name = Glow Border and Switch
    transform = GlowBorder, SwitchMarker
    passiveColor = 0,0,0,255
    activeColor = COLOR_MOARdV_BacklightColor
    variable = fc.GetRCS()
	//range = 0.5, 1.5
	//blend = true
	//flashRate = 0.5
	//colorName = _EmissiveColor
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The name of a transform or a comma-separated list of transforms whose color will be shifted.
'passiveColor': Required.  The RGBA quadruplet or RasterPropMonitor-compatible Named Color
to use when the variable is out of bounds.
'activeColor': Required.  The RGBA quadruplet or RasterPropMonitor-compatible Named Color
to use when the variable is in bounds.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Color Shift operates in threshold mode.  When absent, the shift is done
in boolean mode.
'blend': Optional. Default false.  Ignored if 'range' is not present.  When true, the color is linearly
interpolated between passiveColor and activeColor based on where in the range the variable falls.
'flashRate': Optional.  Default 0.0.  Ignored if 'blend' is enabled.  Specifies one-half of the duty
cycle for a blinking light (in other words, a flashRate of 0.5 means the light is on 0.5 seconds, and then
off for 0.5 seconds).
'colorName': Optional.  Default '_EmissiveColor'.  Controls which color this Color Shift action will alter.
Known working values are '_Color' (diffuse) and '_EmissiveColor'.

An alternate mode for COLOR_SHIFT is a one-time color change.  If 'variable' is omitted, the 'passiveColor'
is applied one time at startup, but the component has no further effect.  This is useful for changing the
color of a component without needing it to change in the future (such as re-tinting a prop).  When used for
this mode, do not include any optional parameters ('range', 'blend', 'flashRate') or configuration errors
will occur.


DYNAMIC_TEXTURE_SHIFT

A Dynamic Texture Shift is a variation of the Texture Shift action (see).  Where a Texture Shift supplies
either a static UV or a pair of UV endpoints, the Dynamic Texture Shift can use any arbitrary texture
shift value, as defined by the return value of the user-supplied variable function 'variable'.  This allows
for greater flexibility in texture shifts, such as switching between multiple UV values depending on 
conditions.

DYNAMIC_TEXTURE_SHIFT
{
	name = Warning Plate color
	transform = WarningPlate
	layers = _MainTex _Emissive
	variable = MOARdVParachuteSafetyTexture()
}
'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The name of the transform whose UV values will be shifted.
'layers': Optional.  Default '_MainTex'.  A space-delimited list of layers where the texture shift should be applied.
Known valid options are '_MainTex' and '_Emissive'.
'variable': Required.  A user-supplied variable that returns a Vector2 (as created using fc.Vector2)
that provides the UV offset from the initial setting.


INT_LIGHT

This action is used to control interior lights.

INT_LIGHT
{
    name = Mk1 Cockpit
	transform = Point light
	variable = fc.GetPersistent("Interior Lights")
	//range = 0.5, 1.5
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The name of the transforms that contain lights.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Int Light operates in threshold mode.  When absent, it operates
in boolean mode.


MODEL_SCALE

This action is used to scale a transform (and its children).  It supports Boolean Mode, Threshold Mode,
and Blend Mode.

MODEL_SCALE
{
	name = Warning Plate Cover
	transform = CoverLoc
	startScale = 0, 0, 0
	endScale = 0, 0, -0.9
	variable = fc.GetRCS()
	//range = 0.5, 1.5
	//blend = true
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The name of the transform that will be scaled.
'startScale': Required.  A Vector3 showing how much should be added to the
transform's scale when the variable is out of range.
'endScale': Required.  A Vec3 showing how much should be added to the transform's
scale when the variable is in range.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Model Scale operates in Threshold Mode.  When absent, it operates
in Boolean Mode.
'blend': Optional. Default false.  Ignored if 'range' is not present.  When true, the transform is linearly
interpolated between startScale and endScale based on where in the range the variable falls.


ROTATION

The Rotation action is used to rotate part of a prop.  This feature is useful for indicator needles and
dial gauges.  Rotations may be Static (single rotation during initialization), Boolean, Threshold,
or Blended.

When in Blended Mode, Rotations can have their movement limited by 'cycleRate', which indicates how many seconds the
animation should require to cycle from startRotation to endRotation.  This capability may be used to simulate
mechanical limitations of instruments, for instance.

In addition, if 'longPath' is set to true, the rotation will take the longer of the two direct routes between
'startRotation' and 'endRotation'.  This allows for instruments where a needle rotates more than 180 degrees
from its start position to its end position.  This applies only in Blended Mode.

One last feature of Blend Mode rotations is the option to specify a 'modulo'.  When defined, the variable is
modulated by the 'modulo' value, which allows rotating needles (such as altimeters or clocks) to rotate around
a face multiple times, but return to the zero position without having to "unwind" back to it.  For instance,
if an altimeter is configured with a range of 0 to 100000 meters, the "hundreds" needle has to circle the gauge
100 times to go from the minimum value to the maximum value.  If the altimeter is configured so it resets to
zero outside the atmosphere, the "hundreds" hand would circle dozens of times to reach the zero position.

TODO: better explanation - that's still murky.

ROTATION
{
	name = Right Arrow
	transform = ArrowRightLoc
	startRotation = 0,0,0
	endRotation = -43.57964,0,0
	variable = fc.GetThrottle()
	range = 0.0, 1.0
	blend = true
	cycleRate = 1.0
	//longPath = true
	//modulo = 1000
	//speed = 1.0
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The name of the transforms that contain lights.
'startRotation': Required.  The Euler angles of the initial rotation position.  This value is
used for Static mode, as well as the other modes for values out of range.
'endRotation': Required.  The Euler angles of the final rotation position.  This value may be
omitted for Static mode.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Rotation operates in Threshold Mode.  When absent, it operates
in Boolean Mode.
'blend': Optional. Default false.  Ignored if 'range' is not present.  When true, the transform is spherically
interpolated between startRotation and endRotation based on where in the range the variable falls.
'longPath': Optional.  Default false.  Ignored if 'blend' is not true.  When true, the rotation
will take the longer route to cycle from the start to the end position, instead of the shortest possible
route.
'modulo': Optional.  Default 0.0.  Ignored if 'blend' is not true.  When set to a positive value, modulo
allows for a variable to cycle a rotation repeatedly around a circle without requiring it to animate the
entire transition (such as looping repeatedly).
'speed': Optional.  Default 0.0.  Ignored if 'blend' is not true, or if speed is not positive.  The speed
parameter describes how quickly the animation can go from 'startRotation' to 'endRotation', in seconds.
Thus, numbers larger than one are faster, while smaller numbers are slower.  If 'modulo' is also valid,
'speed' represents how quickly the Rotation can complete a single circuit.


TEXT_LABEL

The Text Label action is used to display text.  The text can be static (text that is generated once,
and then never altered), or it can be dynamic.  In addition, the text can be configured several
different ways to switch between emissive and non-emissive modes.  There are many configuration options
available for a Text Label.

The 'emissive' field controls when or if the text is emissive.  When set to 'always', the text
will glow at all times.  When set to 'active', the text glows when the variable is greater than
zero.  The 'passive' setting causes the text to glow only when the variable is zero (the opposite
of 'active').  Use 'never' is the text should never glow, and use 'flash' to make the text glow
when the when the text is in the "flash on" state.

The Text Label supports Boolean Mode, Threshold Mode, Blend Mode, and Static Mode.

TEXT_LABEL
{
	name = Name Plate
	transform = IndicatorNameObj
	fontSize = 2.3
	//oneshot = true
	font = InconsolataGo-Bold
	alignment = Center
	anchor = MiddleCenter
	transformOffset = 0.0087,-0.0015
	emissive = active
	//emissive = always
	variable = fc.GetPersistent("MOARdV_Backlight")
	//range = 0.5, 1.5
	//blend = true
	//lineSpacing = 1.0
	flashRate = 1.0
	activeColor = COLOR_MOARdV_BacklightColor
	passiveColor = COLOR_MOARdV_UnlitText
	text = RCS
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The transform in the prop where you want to apply the text.
'fontSize': Required.  How large the text should be in arbitrary units.
'oneshot': Optional.  Default false.  If true, 'text' is considered immutable, meaning that
is will never be updated after its initial value is determined.  If no variables are included
in 'text', it automatically is treated as immutable, so this parameter is only needed for
text that consumes variables that you know won't need updates after initialization.
'font': Required.  The name of the font to use.  Supported fonts include system fonts (which
may not be on every computer), Arial, Inconsolata-Go, <-TODO->
'alignment': Optional.  Default 'Left'.  Controls horizontal justification of the text.  Valid
options are 'Left', 'Right', and 'Center'.
'anchor': Optional.  Default 'UpperLeft'.  Controls vertical justification of the text. Valid
options are combinations of the prefixes 'Upper', 'Middle', or 'Lower' and the suffixes
'Left', 'Center', or 'Right'.
'transformOffset': Optional.  Default (0, 0).  Allows the text to be displaced from the
specified transform.
'emissive': Optional.  Default 'active' or 'always'.  Valid options are 'active', 'always',
'never', 'flash', or 'passive'.
'variable': Optional.  Required if activeColor is defined.  The variable that controls text color
and emissive properties.
'range': Optional.  Ignored if 'variable' is not present.  When 'range' is present, the text color
operates in threshold mode.  When absent, it operates in Boolean Mode.
'blend': Optional.  Default false.  Ignored if 'range' is missing.  Allows the text to blend
smoothly between 'activeColor' and 'passiveColor'.
'lineSpacing': Optional.  Default 1.0.  Scaled line-to-line spacing on multi-line text.
'flashRate': Optional. Default 0.0.  Ignored if 'blend' is true.  Sets the flash rate of the text
when the controlling variable is in range.  Provides 1/2 of the duty cycle of the flash (so a
flashRate of 0.5 means "on for 0.5 seconds, off for 0.5 seconds").
'activeColor': Optional.  Required is 'variable' is defined.  Defines the color of the text when
the variable is in range.
'passiveColor': Required.  Defines the default color of the text if 'variable' is not defined, and
the color of the text when 'variable' is defined and it is out of range.
'text': Formatted rich text (see Formatted Rich Text).

If 'variable' and 'activeColor' are omitted, the Text Label operates in Static Mode.


TEXTURE_SHIFT

This action is used to shift the texture coordinates attached to a specified
Transform in the prop object.

TEXTURE_SHIFT
{
    name = Arrow
    transform = LabelObj
    startUV = 0.5, 0.6
	//endUV = 1.0, 0.6
    layers = _MainTex _Emissive
	//variable = fc.GetPersistent("Interior Lights")
	//range = 0.5, 1.5
	//blend = true
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The transform in the prop where you want to shift the texture.
'startUV': Required.  The (u,v) displacement for the texture when the variable is out of range.
'endUV': Required.  The (u,v) displacement for the texture when the variable is in range.
'layers': Optional.  Default '_MainTex'.  A space-delimited list of layers where the texture shift should be applied.
Known valid options are '_MainTex' and '_Emissive'.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Texture Shift operates in Threshold Mode.  When absent, it operates
in Boolean Mode.
'blend': Optional. Default false.  Ignored if 'range' is not present.  When true, the texture is linearly
interpolated between startUV and endUV based on where in the range the variable falls.

Texture Shift has an alternate Static Mode where it can be used to apply a one-time change to a texture.  This mode
is useful for texture atlases.  Omitting 'variable', and not included 'range' or 'blend' will activate this mode.
When active, 'startUV' is applied to the texture at startup, but the action has no further affect.  The sample above
demonstrates this static mode


TRANSLATION

A translation may be used to displace a portion of a prop, such as moving the needle of an indicator
or shifting a joystick or throttle position.

TRANSLATION
{
	name = Right Arrow
	transform = ArrowRightLoc
	startTranslation = 0,0,0
	endTranslation = 0,0,0.005
	variable = fc.GetThrottle()
	range = 0.0, 1.0
	blend = true
	//speed = 1.0
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'transform': Required.  The name of the transforms that contain lights.
'startTranslation': Required.  The displacement for the initial position.  This value is
used for Static mode, as well as the other modes for values out of range.
'endTranslation': Required.  The displacement for the final position.  This value may be
omitted for Static mode.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Translation operates in Threshold Mode.  When absent, it operates
in Boolean Mode.
'blend': Optional. Default false.  Ignored if 'range' is not present.  When true, the translation is
interpolated between startTranslation and endTranslation based on where in the range the variable falls.
allows for a variable to cycle a rotation repeatedly around a circle without requiring it to animate the
entire transition (such as looping repeatedly).
'speed': Optional.  Default 0.0.  Ignored if 'blend' is not true, or if speed is not positive.  The speed
parameter describes how quickly the animation can go from 'startTranslation' to 'endTranslation', in seconds.
Thus, numbers larger than one are faster, while smaller numbers are slower.


TRIGGER_EVENT

This action is used to activate an event when a specified variable is true (Boolean Mode) or
in range (Threshold Mode).  The event may be configured as a repeated event by setting 'autoRepeat' to true,
which will fire the event every FixedUpdate until the variable is no longer in range.

Use caution with a Trigger Event: if there are multiple occurrences in a single craft, every single
trigger event will fire, unless the script it runs was designed to "know" if it's being called multiple
times per update.

TRIGGER_EVENT
{
    name = My Cool Action
	event = MyCoolAction()
	variable = fc.GetPersistent("Interior Lights")
	//range = 0.5, 1.5
	//autoRepeat = true
}

'name': Optional.  Default '(anonymous)'.  A name for the action.
'event': Required.  The event that is triggered when the trigger event is active.
'variable': Required.  The name of the variable script to evaluate.
'range': Optional.  When present, the Trigger Event operates in threshold mode.  When absent, it operates
in boolean mode.
'autoRepeat': Optional.  Default 'false'.  When set to true, the onClick event
triggers every FixedUpdate until the button is released.
