The MASMonitor prop module powers monitor displays, ranging from simple single-line
digital readouts to full-featured MFDs.  MASMonitor is more complex to set up than
a MASComponent, since it entails a render texture and multiple pages.  The MASMonitor
is comparable to the RasterPropMonitor class, but it is substantially more flexible
in its design.

When placing components in a monitor, the upper left corner is treated as the
origin (0, 0), and positive Y is "down" on the display.  For graphical components,
displacement is by pixel, while text displacement is by character (based on the fontSize).

MODULE
{
  name = MASMonitor

  screenTransform = FlatMon40x10Screen
  //layer = _Emissive
  screenSize = 512, 512
  font = InconsolataGo-Bold
  fontSize = 16, 32
  textColor = 255, 255, 255, 255
  backgroundColor = 0, 0, 32, 255
  monitorID = %AUTOID%

  //++ TODO
  //variable = blah
  //range = blah
  //disabledColor = blah ?
  //-- TODO

  page = Standby_Page
  page = Orbit_Page
  ...
}

The configuration parameters are

'screenTransform': Required.  The name of the transform in the prop that contains a screen display.
'layer': Optional.  Defaults to '_Emissive'.  A space-separated list of the layers in 'screenTransform'
that will be rendered to.
'screenSize': Required.  The width and height of the render texture that the monitor will use.
'font': Required.  The name of the font (bundled, system, or user) that is used for rendering text.
-TODO: Comma-separated list, and support multiple fonts-
'fontSize': Required.  The width and height of the text that is rendered on the monitor, in screen
pixel size.  All texts will be fixed-width, even if the referenced font is not.
'textColor': Required.  The default color of text rendered on the screen.  Colors may be overridden
with tags (see Formatted Rich Text).
'backgroundColor': Required.  The color the monitor will be cleared to before rendering.
'page': Required.  One or more entries referring to named pages that are displayed on the monitor.
Pages may be omitted, in which case the monitor won't do anything.  The first listed page is the
default page that is visible when first entering IVA.
'monitorID': Optional.  Defaults to '%AUTOID%'.  Specifies the name of the persistent variable used
to contain the current page selection.  Defaulting to %AUTOID% allows on-prop buttons to likewise
use %AUTOID%, but a unique name might be better for a monitor controlled by props located elsewhere.

CAUTION: Only use one MASMonitor per prop.  Multiple MASMonitor modules will lead to incorrect behavior.


MAS_PAGE
{
  name = Standby_Page
  
  ...
}

Monitor pages are defined in config files using the MAS_PAGE node type.  Each page must have a
name.  A page may have one or more nodes inside it describing the page layout (text, graphical
objects, etc).  These nodes are layered during rendering, with the first node listed being
the farthest from the camera.  If a page has no nodes, it will result in a completely blank
page.

Individual nodes may be optionally disabled and enabled by querying a variable, in much the way
that MASComponent actions use variables.  Page nodes only support the Boolean and Threshold Modes.

Because fonts are treated as fixed-width, there is the possibility that scaling problems will
cause unusually-wide characters to be compressed horizontally, which may hinder readability.
This problem may be worse if the [hw] tag is used with those fonts.

Pages are selected by setting the persistent identified by `monitorID` to the name (string) of
the desired page.  In the example config above, for instance, a button on the same prop could use
`fc.SetPersistent("%AUTOID%", "Orbit_Page")` to select the second page in the list.


CAMERA

The Camera node renders the view from cameras on board the vessel.  Such cameras can be used for
docking, or inspecting the exterior of the craft, or surveying things from a distance.  The
camera objects are created by adding a MASCamera module to a part, and correctly configuring it
(see MASCamera).

Cameras are accessed by name, and each camera should have a unique name.  To allow some generalization
in monitor configuration, the MASFlightComputer has method that allow cameras to be addressed by
number, but MAS makes no guarantees on the ordering of those cameras.

For the most efficient use of memory, the size of the camera should be a power-of-2 (64, 128, 256,
512).  It does not have to be square. For instance, a 512 x 256 size is okay.

TODO: Add an invalid camera texture optional parameter.

CAMERA
{
	name = ActionCam
	position = 0,0
	size = 256, 256
	camera = "MyActionCam"
	//camera = fc.GetCameraName(0)
	//camera = fc.GetPersistent("My-Active-Camera-Variable")
	//variable = fc.GetPersistentAsNumber("ShowCamera")
	//range = 0.5, 1.1
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'position': Required.  The location on the monitor where the upper-left
corner of the camera view will be placed.
'size': Required.  The size of the camera view.
'camera': Required.  Identifies which camera should be rendered.  If an invalid name is provided,
nothing is rendered.
'variable': Optional.  When present, the variable will control whether the horizon
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


HORIZON

The Horizon node renders an artificial horizon, such as would be found on aircraft.  It is
not intended to replace a navball for full 3D positional data, since it only provides visual
roll and pitch cues.  Note that both the pitch and roll variables *are* user configurable,
so there is no requirement to use this feature strictly for those flight parameters.

The texture is treated like a Vertical Strip with the additional feature of being able to
rotate the texture around the center of its displayed area.  Texture coordinates are clamped, so for best
results, the texture should have a one pixel wide border of whatever the background color
should be.

HORIZON
{
	name = horizon
	texture = JSI/RasterPropMonitor/Library/Components/HUD/ladder
	position = 0,0
	size = 256, 256
	pitch = fc.Pitch()
	pitchRange = -90, 90
	displayPitchRange = 1536,512
	roll = fc.Roll()
	rollRange = -180,180
	displayRollRange = -180,180
	//variable = fc.GetBrakes()
	//range = 0.5, 1.1
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'texture': Required.  The texture that will be used for the horizon.
'position': Required.  The location on the monitor where the center
of the horizon will be placed.
'size': Required.  The size of displayed portion of the horizon.
'pitch': Required.  The variable that controls vertical texture movement.
'pitchRange': Required.  The range of values that will affect the horizon
pitch.  Values outside this range are clamped to this range.
'displayPitchRange': Required.  The pixel offsets from the top of the texture
that correspond to the first and second 'pitchRange' values.
'roll': Required.  The variable that controls texture roll.
'rollRange': Required.  The range of valid roll values.  Values outside this
range are clamped to this range.
'displayRollRange': Required.  The range that the texture will be rotated.
Maximum values should stay between [-180, +180] for a normal horizon.
'variable': Optional.  When present, the variable will control whether the horizon
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


HORIZONTAL_BAR

A Horizontal Bar node renders a bar graph that grows or shrinks horizontally in
response to the source variable.  The bar graph may be a solid color, or it may
use a texture.  If a texture is used, the UV values are scaled in proportion to
how full the bar is (in other words, the texture is not squished as the bar goes
from full to empty), which allows a texture with a gradient or other pattern to be used.

HORIZONTAL_BAR
{
	name = G-Forces
	position = 16, 272
	size = 128, 32
	source = fc.GForce()
	sourceRange = 0, 5
	sourceColor = 192,192,128,255 // Optional, may be white for texture application.  Or not.
	//texture = AvionicsSystems/Textures/horiz_bargraph
	anchor = Left
	borderWidth = 2
	borderColor = 128, 64, 64,255
	//variable = fc.GetBrakes()
	//range = 0.5, 1.1
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'position': Required.  The location on the monitor where the upper-left corner
of the bar graph will be placed.
'size': Required.  The size of the graph.
'source': Required.  The variable that will be graphed.
'sourceRange': Required.  The values for the left and right ends of the bar.
'sourceColor': Optional.  Defaults to white.  The color of the bar graph.
'texture': Optional.  When present, the named texture is drawn so it will fill the
graphs area.  Color textures may be used - the sourceColor is multiplied by the texture
color in that case.  If no texture is provided, the graph is treated as a solid color.
'anchor': Optional.  Defaults to 'Left'.  Defines the anchor of the bar graph.  'Left'
means the left side of the region, in which case the graph grows towards the right.
'Right' means the opposite: the graph starts on the right and it grows to the left.
'Middle' mwans the graph starts in the center, and it grows to the left if the source
value is below 1/2 of the range, or it grows to the right if the source value is above
1/2 of the range.
'borderWidth': Optional.  Required if 'borderColor' is present.  The width in pixels
for a border surrounding the graph area.  This border is placed outside the region
specified by 'position' and 'size'.  In the above example, the border is 2 pixels
wide, which means it is in x-position 14-16 and 496-498.
'borderColor': Optional.  Required if 'borderWidth' is present.  The color of the
graph's border.
'variable': Optional.  When present, the variable will control whether this strip
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


HORIZONTAL_STRIP

A Horizontal Strip node renders part of a texture in response to a variable input.  It can be
used for a virtual compass instrument or other applications.  The full height of the source
texture is always displayed in a horizontal strip, but only a portion of the width is visible
at any given time.

HORIZONTAL_STRIP
{
	name = Heading
	texture = JSI/RasterPropMonitor/Library/Components/NavBall/hdg2
	position = 448,20
	size = 128,24
	input = fc.Heading()
	inputRange = 0, 360
	displayRange = 0,1024
	displayWidth = 128
	//wrap = false
	//variable = fc.GetBrakes()
	//range = 0.5, 1.1
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'texture': Required.  The texture that will be used for the horizontal strip.
'position': Required.  The location on the monitor where the upper-left corner
of the strip will be placed.
'size': Required.  The size of displayed portion of the strip.
'input': Required.  The variable that will be used to control the strip.
'inputRange': Required.  The range of values that will affect the position of
the displayed strip.  The result of 'input' is clamped to this range.
'displayRange': Required.  Controls how the 'inputRange' is mapped to texture
locations.  Lists the position in pixels for the lower and upper bound of
the displayed image.  For instance, in the above example, when heading is 0,
the 0 pixel location is in the center of the strip.  When the heading is 180,
the 512 pixel is visible.
'displayWidth': Required.  The width of the visible portion of 'texture', in
pixels as measured on the texture.  Eg, if the texture is 512 pixels wide, and
you want the 25% of it visible, you would use 'displayWidth = 128'.
'wrap': Optional.  Default false.  When true, indicates that the texture is expected to
wrap around (like a continuous ribbon).  When false, the texture coordinates are
clamped to the ends of the texture.
'variable': Optional.  When present, the variable will control whether this strip
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


IMAGE

An Image node renders an image.  The image's position and size may be specified, including resizing
the image from its original.

IMAGE
{
	name = PFD overlay
	texture = JSI/RasterPropMonitor/Library/Components/NavBall/StaticMask
	//position = 128,256
	//size = 256,256
	//variable = fc.GetPersistentAsNumber("ShowImage")
	//range = 0.5, 1.1
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'texture': Required.  A URI to the texture that will be displayed.
'position': Optional.  Default (0,0).  The pixel offset from the upper-left
corner of the page.
'size': Optional.  Defaults to the native size of the texture.  Specifies the
desired pixel width and height of the image.
'variable': Optional.  When present, the variable will control whether this image
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


LINE_GRAPH

A Line Graph node is used to visualize numeric data using a line graph.  The
graph updates regularly, with the x-axis representing time (at one second per
pixel) and the y-axis representing the data being tracked (with the value per
pixel defined by the sourceRange and graph size).

Note that the width of the graph and the sample rate affect the memory and
performance of this node: the node tracks a number of samples equal to the
width divided by the sample rate, and once the graph is full, the older values
are moved in memory.  Many detailed graphs may cause some lag.

LINE_GRAPH
{
	name = Atmosphere Altitude
	position = 16, 16
	size = 480, 240
	source = fc.Altitude()
	sourceRange = 0, fc.AtmosphereTop()
	sourceColor = 0,160,182,255
	sampleRate = 1
	borderWidth = 2
	borderColor = 0, 80, 91,255
	//variable = fc.GetBrakes()
	//range = 0.5, 1.5
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'position': Required.  The pixel offset from the upper-left
corner of the page for this graph.
'size': Required.  Specifies the desired pixel width and height of the graph.
'source': Required.  The variable that will be graphed.
'sourceRange': Required.  The values for the bottom and top of the y-axis.
'sourceColor': Required.  The color of the line graph.
'sampleRate': Required.  How frequently the variable will be sampled.  Values
below 1 will be clamped to 1.
'borderWidth': Optional.  Required if 'borderColor' is present.  The width in pixels
for a border surrounding the graph area.  This border is placed outside the region
specified by 'position' and 'size'.  In the above example, the border is 2 pixels
wide, which means it is in x-position 14-16 and 496-498.
'borderColor': Optional.  Required if 'borderWidth' is present.  The color of the
graph's border.
'variable': Optional.  When present, the variable will control whether this graph
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


NAVBALL

A NavBall node is used to render a navball on the monitor.  This can be used to
create a primary flight display, or, with the right configuration, a 3D spherical
HUD navigation aid.

Note that, at present, MAS does not include a NavBall model and texture.  The
example below assumes that RPM is installed.  The ASET Props pack also includes
a navball model.

NAVBALL
{
	name = PFD navball
	model = JSI/RasterPropMonitor/Library/Components/NavBall/NavBall
	texture = JSI/RasterPropMonitor/Library/Components/NavBall/NavBall000
	//position = 256, 256
	size = 340, 340
	//opacity = 0.9
	//color = 0, 255, 0, 200
	//variable = fc.GetBrakes()
	//range = 0.5, 1.5
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'model': Required.  The URI to the navball model.  While this is typically a
simple sphere, there is no requirement to use a ball for this component.
'texture': Required.  The texture that is applied to the navball model.
'position': Optional.  Default the middle of the screen.  A displacement to
move the navball on the screen.  The 'position' is the center of the navball.
'size': Required.  Specifies the pixel width and height of the image.
Note that the navball is rendered to a square, so using a non-square size here
will distort the shape of the navball.
'opacity': Optional.  Defaults to 1.0.  Controls the alpha value of the navball.
Setting this value less than one will make the navball partially transparent.
'color': Optional.  When present, all icon markers will use this color instead
of stock-default colors.  This option may make the navball harder to read, since
multiple direction vectors use the same icons.
'variable': Optional.  When present, the variable will control whether the navball
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


TEXT

A Text node renders text.  This text may be static (unchanging) data, or it may use variables.
Simple text can be defined in the Text node using a 'text' field, while complex or multi-line
text residing in a separate file may referenced with a 'textfile' field.  All text supports
Formatted Rich Text.

These text nodes are not as complex as a Text Label - there are no controls for alignment,
font size, anchors, etc.  However, they still support Formatted Rich Text.

TEXT
{
  name = Important Text Node
  text = Hello, world!
  //textfile = AvionicsSystems/Sample/helloworld.txt
  //font = InconsolataGo-Bold
  //fontSize = 16, 32
  //textColor = 0, 255, 0, 255
  //position = 0,0
  //variable = fc.GetRCS()
  //range = 0.5, 1.5
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'text': Required if there is not a 'textfile' entry.  Text that is displayed for
this node, similar to a Text Label action in MASComponent.
'textfile': Required if there is not a 'text' entry; ignored if there is a
'text' field.  Refers to a text file that contains the text that will be rendered.
The 'textfile' is usually the better choice for multi-line text.
'font': Optional. The name of the font to use for rendering
this text.  If this parameter is omitted, the font listed in MASMonitor is used.
'fontSize': Optional.  The width and height of this text as rendered on the
screen, in pixels.  If it is omitted, the default fromn MASMonitor is used.
'textColor': Optional.  The default text color for this text.  If the entry is
omitted, the default found in MASMonitor is used.
'position': Optional.  Default (0, 0).  An offset from the upper-left corner for
the text being rendered.  The offset is in units of character columns and rows,
not pixels.
'variable': Optional.  When present, the variable will control whether this text
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


VERTICAL_BAR

A Vertical Bar node renders a bar graph that grows or shrinks vertically in
response to the source variable.  The bar graph may be a solid color, or it may
use a texture, as described in the Horizontal Bar entry.

VERTICAL_BAR
{
	name = VSI
	position = 256, 272
	size = 32, 128
	source = fc.PseudoLog10(fc.VerticalSpeed())
	sourceRange = -5, 5
	sourceColor = 64,192,64,255
	anchor = Middle
	//texture = AvionicsSystems/Textures/horiz_bargraph
	borderWidth = 2.5
	borderColor = 64, 255, 64,255
	//variable = fc.GetBrakes()
	//range = 0.5, 1.1
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'position': Required.  The location on the monitor where the upper-left corner
of the bar graph will be placed.
'size': Required.  The size of the graph.
'source': Required.  The variable that will be graphed.
'sourceRange': Required.  The values for the bottom and top ends of the bar.
'sourceColor': Optional.  Defaults to white.  The color of the bar graph.
'texture': Optional.  When present, the named texture is drawn so it will fill the
graph's area.  Color textures may be used - the sourceColor is multiplied by the texture
color in that case.  If no texture is provided, the graph is treated as a solid color.
'anchor': Optional.  Defaults to 'Bottom'.  Defines the anchor of the bar graph.  'Bottom'
means the bottom side of the region, in which case the graph grows towards the top.
'Top' means the opposite: the graph starts on the top and it grows to the bottom.
'Middle' mwans the graph starts in the center, and it grows to the bottom if the source
value is below 1/2 of the range, or it grows to the top if the source value is above
1/2 of the range.
'borderWidth': Optional.  Required if 'borderColor' is present.  The width in pixels
for a border surrounding the graph area.  This border is placed outside the region
specified by 'position' and 'size'.
'borderColor': Optional.  Required if 'borderWidth' is present.  The color of the
graph's border.
'variable': Optional.  When present, the variable will control whether this strip
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.


VERTICAL_STRIP

A Vertical Strip node renders part of a texture in response to a variable input.  It can be
used for a aircraft VSI and altitude strips on a HUD or other applications.  The full width of the source
texture is always displayed in a vertical strip, but only a portion of the height is visible
at any given time.

VERTICAL_STRIP
{
	name = VSI
	texture = JSI/RasterPropMonitor/Library/Components/HUD/leftscale
	position = 86,64
	size = 64,320
	input = fc.PseudoLog10(fc.VerticalSpeed())
	inputRange = -5, 5
	displayRange = 1845,208
	displayWidth = 640
	//wrap = false
	//variable = fc.GetBrakes()
	//range = 0.5, 1.1
}

'name': Optional.  Default '(anonymous)'.  A name for the node.
'texture': Required.  The texture that will be used for the horizontal strip.
'position': Required.  The location on the monitor where the upper-left corner
of the strip will be placed.
'size': Required.  The size of displayed portion of the strip.
'input': Required.  The variable that will be used to control the strip.
'inputRange': Required.  The range of values that will affect the position of
the displayed strip.  The result of 'input' is clamped to this range.
'displayRange': Required.  Controls how the 'inputRange' is mapped to texture
locations.  Lists the position in pixels for the lower and upper bound of
the displayed image.  Pixels count up from the top of the image (the top of the
image is '0', the bottom is whatever the height of the image is).
'displayHeight': Required.  The height of the visible portion of 'texture', in
pixels as measured on the texture.  Eg, if the texture is 512 pixels tall, and
you want the 25% of it visible, you would use 'displayHeight = 128'.
'wrap': Optional.  Default false.  When true, indicates that the texture is expected to
wrap around (like a continuous ribbon).  When false, the texture coordinates are
clamped to the ends of the texture.
'variable': Optional.  When present, the variable will control whether this strip
is rendered or not.
'range': Optional.  Ignored if 'variable' is not present.  When present, the
'variable' operates in Threshold Mode; when absent, the 'variable' operates in
Boolean Mode.
